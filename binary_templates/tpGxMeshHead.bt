// Woeful_Wolf

struct {
	struct {
		struct {
			float x;
			float y;
			float z;
		} boundingBoxCoord1;
		struct {
			float x;
			float y;
			float z;
		} boundingBoxCoord2;
		uint32	totalVertexDataSize;
		uint32  unknownFlag <format=hex>;
		uint32	totalIndicesDataSize;
		ushort	unknownShort0;
		ushort	unknownShort1;
		float unknownFloat;
		uint32	boneCount;
		local uint32 bonesStartOffset = FTell();
		uint32	offsetToBones;
		uint32 	boneDataCount;
		local uint32 bonesDataStartOffset = FTell();
		uint32	offsetToBonesData;
		uint32 	objectGroupCount;
		local uint32 objectGroupsStartOffset = FTell();
		uint32	offsetToObjectGroups;
		uint32 	materialCount;
		local uint32 materialsStartOffset = FTell();
		uint32	offsetToMaterials;
		uint32 	objectCount;
		local uint32 objectsStartOffset = FTell();
		uint32	offsetToObjects;
	} header;

	FSeek( header.bonesStartOffset + header.offsetToBones );
	struct {
	struct {
		local uint32 nameStartOffset = FTell();
		uint32  offsetToName;
		local uint32 returnPos = FTell();
		FSeek(nameStartOffset + offsetToName);
		string name;
		FSeek(returnPos);
		int32	parentBoneIndex;
		float   unknownFloats[10];
	} bone[header.boneCount] <optimize=false>;
	} bones;

	FSeek( header.bonesDataStartOffset + header.offsetToBonesData );
	struct {
	struct {
		local uint32 nameStartOffset = FTell();
		uint32  offsetToName;
		local uint32 returnPos = FTell();
		FSeek(nameStartOffset + offsetToName);
		string name;
		FSeek(returnPos);
		int32	unknownParentIndex;
		float	unknownFloat;
		float   unknownMatrix0[16];
		float   unknownMatrix1[16];
	} boneData[header.boneDataCount] <optimize=false>;
	} bonesData;

	FSeek( header.objectGroupsStartOffset + header.offsetToObjectGroups );
	struct {
	struct {
		uint32  indicesStartOffset;
		uint32  unknownUInt32_1;
		uint32  unknownUInt32_2;
		uint32  vertexCount;
		uint32  indicesCount;
		uint32  unknownUInt32_5;
		uint32  unknownUInt32_6;
		uint32  vertexDataCount;
		local uint32 vertexDataStartOffset = FTell();
		uint32  offsetToVertexData;
		
		local uint32 returnPos = FTell();
		FSeek(vertexDataStartOffset + offsetToVertexData);
		struct {
			uint32  objectGroupVertexDataOffset;
			uint32  unknownUInt32_1;
			uint32  unknownUInt32_2;
			uint32  vertexStructSize;
			byte	vertexStructFlag;
			FSeek(((FTell() / 8) + 1) * 8);
		} vertexData[vertexDataCount] <optimize=false>;

		FSeek(returnPos);
		FSeek(((FTell() / 8) + 1) * 8);
	} objectGroup[header.objectGroupCount] <optimize=false>;
	} objectGroups;

	FSeek( header.materialsStartOffset + header.offsetToMaterials );
	struct {
	struct {
		local uint32 nameStartOffset = FTell();
		uint32 offsetToName;
		local uint32 unknownByteStartOffset = FTell();
		uint32 offsetToUnknownByte;
		uint32 unknownUInt32;
		local uint32 returnPos = FTell();
		FSeek(nameStartOffset + offsetToName);
		string name;
		FSeek(unknownByteStartOffset + offsetToUnknownByte);
		byte unknownByte;
		FSeek(returnPos);
	} material[header.materialCount] <optimize=false>;
	} materials;

	FSeek( header.objectsStartOffset + header.offsetToObjects );
	struct {
	struct {
		uint32 objectGroupIndex;
		uint32 materialIndex;
		uint32 indicesStart;
		uint32 indicesCount;
		struct {
			float x;
			float y;
			float z;
		} boundingBoxCoord1;
		struct {
			float x;
			float y;
			float z;
		} boundingBoxCoord2;
	} object[header.objectCount] <optimize=false>;
	} objects;

	local uint32 assetResourceStart = FTell();
	local int i;
	local int k;
	for (i = 0; i < header.objectGroupCount; i++) {
		struct {
			for (k = 0; k < objectGroups.objectGroup[i].vertexDataCount; k++) {
				FSeek(assetResourceStart + objectGroups.objectGroup[i].vertexData[k].objectGroupVertexDataOffset);
				struct {
					if (objectGroups.objectGroup[i].vertexData[k].vertexStructSize == 12) {
						if (objectGroups.objectGroup[i].vertexData[k].vertexStructFlag == 0) {
							struct {
								float x;
								float y;
								float z;
							} vertexPos[objectGroups.objectGroup[i].vertexCount];
						} else if (objectGroups.objectGroup[i].vertexData[k].vertexStructFlag == 6) {
							struct {
								float boneWeight0;
								float boneWeight1;
								float boneWeight2;
							} vertexWeights[objectGroups.objectGroup[i].vertexCount];
						} else {
							struct {
								float unknownFloats[3];
							} unknownStruct[objectGroups.objectGroup[i].vertexCount];
						}
					} else if (objectGroups.objectGroup[i].vertexData[k].vertexStructSize == 4) {
						if (objectGroups.objectGroup[i].vertexData[k].vertexStructFlag == 1) {
							struct {
								ubyte nx;
								ubyte ny;
								ubyte nz;
								ubyte dummy;
							} vertexNormal[objectGroups.objectGroup[i].vertexCount];
						} else if (objectGroups.objectGroup[i].vertexData[k].vertexStructFlag == 2) {
							struct {
								ubyte unknownBytes[4];
							} unknownStruct[objectGroups.objectGroup[i].vertexCount] <comment="Perhaps Tangents?">;
						} else if (objectGroups.objectGroup[i].vertexData[k].vertexStructFlag == 4) {
							struct {
								hfloat u;
								hfloat v;
							} vertexUV[objectGroups.objectGroup[i].vertexCount];
						} else if (objectGroups.objectGroup[i].vertexData[k].vertexStructFlag == 5) {
							struct {
								ubyte boneIndex0;
								ubyte boneIndex1;
								ubyte boneIndex2;
								ubyte boneIndex3;
							} vertexBones[objectGroups.objectGroup[i].vertexCount];
						} else {
							struct {
								ubyte unknownBytes[4];
							} unknownStruct[objectGroups.objectGroup[i].vertexCount];
						}
					}

				} vertexData;
			}
			uint32 ending0;
		} objectGroupVertexData;
	}

	// TODO: I CANT FIGURE OUT PADDING SO JUST SKIPPING
	uint32 padding<hidden=true>;
	while (padding == 1077952576) {
		uint32 padding<hidden=true>;
	}
	FSkip(-4);

	for (i = 0; i < header.objectGroupCount; i++) {
		struct {
			for (k = 0; k < objectGroups.objectGroup[i].indicesCount/3; k++) {
				struct {
					ushort v0;
					ushort v1;
					ushort v2;
				} loop;
			}
			uint32 ending0;
		} objectGroupIndices;
	}


} tpGxMeshHead;