struct {
    char    id[4];
    uint32  version;
    uint32  packFileSizeA;
    uint32  packFileSizeB;
    uint32  unknown0;
    uint32  pathCount;
    local uint32 pathsStartOffset = FTell();
    uint32  offsetToPaths;
    uint32  assetCount;
    local uint32 assetsStartOffset = FTell();
    uint32  offsetToAssets;
    uint32  fileCount;
    local uint32 filesStartOffset = FTell();
    uint32  offsetToFiles;
} header;

if (header.pathCount != 0) {
FSeek( header.pathsStartOffset + header.offsetToPaths );
struct{
    struct {
        uint32  hash<format=hex>;
        local uint32 pathStartOffset = FTell();
        uint32  offsetToPath;
        uint32  unknown0;
        local uint returnPos = FTell();
        FSeek(pathStartOffset + offsetToPath);
        string path;
        FSeek(returnPos);
    } path[header.pathCount] <optimize=false>;
} paths;
}

if (header.assetCount != 0) {
FSeek( header.assetsStartOffset + header.offsetToAssets );
struct {
    struct {
        uint32  hash<format=hex>;
        local uint32 nameStartOffset = FTell();
        uint32  offsetToName;
        uint32  fileSize;
        uint32  offsetToFileStart;
        uint32  offsetToFileEnd;
        FSeek(nameStartOffset + offsetToName);
        string name;
    } file[header.assetCount] <optimize=false>;
} assets;
}

if (header.fileCount != 0) {
FSeek( header.filesStartOffset + header.offsetToFiles );
struct {
    struct {
        uint32  hash<format=hex>;
        local uint32 nameStartOffset = FTell();
        uint32  offsetToName;
        uint32  fileSize;
        uint32  offsetToFileStart;
        uint32  offsetToFileEnd;
        FSeek(nameStartOffset + offsetToName);
        string name;
        
    } subfile[header.fileCount] <optimize=false>;
} files;
}